

# reduce

把一个序列归结为一个值

```
reduce(function, sequence[, initial]) -> value
```

接受2个/3个参数。第一个是函数，接受2个参数。第二个是一个可迭代序列，第三个（可选）是一个初始值。

- 官方描述：

> Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the
> sequence is empty.

把一个函数从左到右依次作用到这个序列上，最后得到一个值。其中initial是可选的初始值。通过查看源码，若initial未赋初值，则从sequence里取出第一个作为initial，然后再依次计算。其中function可以使用lambda匿名函数。

- 源码：

  ```python
      it = iter(sequence)
      if initial is _initial_missing:
          try:
              value = next(it)
          except StopIteration:
              raise TypeError("reduce() of empty sequence with no initial value") from None
      else:
          value = initial
  
      for element in it:
          value = function(value, element)
      return value
  ```

# 装饰器

**装饰器（Decorator）**是 Python 非常重要的组成部分，它可以修改或扩展其他函数的功能，并让代码保持简短。

一切皆对象，在 Python 中，**函数可以根据给定的参数返回一个值或一个函数**，同时函数也可以作为参数。

> 而装饰器就是把原来的函数封装成新函数，然后可以在调用前，调用后增加逻辑。通常用于增强函数功能，如打印日志，计算耗时，校验等通用逻辑。

## 无参版

```python
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

如上，打印日志的装饰器

观察上面的`log`，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

```python
@log
def now():
    print('2015-3-25')
```

调用`now()`函数，不仅会运行`now()`函数本身，还会在运行`now()`函数前打印一行日志：

```python
>>> now()
call now():
2015-3-25
```

把`@log`放到`now()`函数的定义处，相当于执行了语句：

```python
now = log(now)
```

## 传参版

如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：

```python
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

这个3层嵌套的decorator用法如下：

```python
@log('execute')
def now():
    print('2015-3-25')
```

执行结果如下：

```python
>>> now()
execute now():
2015-3-25
```

和两层嵌套的decorator相比，3层嵌套的效果是这样的：

```python
>>> now = log('execute')(now)
```

## 最后一步：属性迁移

以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有`__name__`等属性，但你去看经过decorator装饰之后的函数，它们的`__name__`已经从原来的`'now'`变成了`'wrapper'`：

```python
>>> now.__name__
'wrapper'
```

因为返回的那个`wrapper()`函数名字就是`'wrapper'`，所以，需要把原始函数的`__name__`等属性复制到`wrapper()`函数中，否则，有些依赖函数签名的代码执行就会出错。

不需要编写`wrapper.__name__ = func.__name__`这样的代码，Python内置的`functools.wraps`就是干这个事的，所以，一个完整的decorator的写法如下：

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

> 补充：`functools.wraps` 是 Python 标准库中 `functools` 模块提供的一个装饰器，它用于在定义装饰器时保留被装饰函数的元信息（如函数名、文档字符串等）。
